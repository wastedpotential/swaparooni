<!doctype html>
<html>
  <head>
    <script src="https://pixijs.download/release/pixi.js"></script>
    <script src="scripts/assets.js"></script>
    <script src="scripts/utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js"></script>
    <style>
        html, body {
            position: relativ;
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* prevent scrollbars */
        }
        .container {
            position: absolute;
        }
        .menu {
            position: absolute;
        }
    </style>
    <title>wasted potential</title>
  </head>
  <body>
      <div class="container"></div>
      <div class="menu">
          <button type="button" onclick="tweenIt()">Tweiner</button>
        </div>
    <script>
        // TODO - move everything to separate files
        // TODO - make code more functional
        // TODO: add timer to switch back to main site title after a short time

        const animationTypes = {
            NONE: 'none',
            SLIDEY: 'slidey',
            EXPLODEY: 'explodey',
        }
        let currentPhrase = '';

        function tweenIt() {
            for (let i=0; i<letters.length; i++) {
                if (letters[i].used) letters[i].used = false;
            }
            let newIndex = uniqueRandomIndex(anagrams.length, anagrams.indexOf(currentPhrase));
            currentPhrase = anagrams[newIndex];
            showNew(currentPhrase, animationTypes.EXPLODEY);
            changePageTitle(currentPhrase);
        }

        function populateLetterArrays(str, objectArray) {
            const line = [];
            for (var i = 0; i < str.length; i++) {
                const nextLetter = str.charAt(i);
                const letterObj = objectArray.find(e => {
                    return !(e.used) && (e.char == nextLetter);
                });
                line.push(letterObj);
                letterObj.used = true;
            }
            return line;
        }

        function totalWidth(items) {
            var total = items.reduce(
                (partialSum, a) => partialSum + a.w, 0
            );
            return total;
        }
      
        function getLetterObjArray(stringArray, letterObjectsArray) {
            const lineArray = [];
            for (const str of stringArray) {
                lineArray.push(populateLetterArrays(str, letterObjectsArray));
            }
            return lineArray;
        }
      
        function calculateLetterObjPositions(lineArray, letterHeight) {
            const startY = -0.5 * lineArray.length * letterHeight;
            for (let i=0; i<lineArray.length; i++){
                const line = lineArray[i];
                const totalW = totalWidth(line);
                let lineX = -0.5 * totalW;
                const lineStartY = i * letterHeight + startY;
                for (let j=0; j<line.length; j++) {
                    const ltr = line[j];
                    ltr.destX = lineX;
                    ltr.destY = lineStartY;
                    lineX += line[j].w;
                }
            }
            return lineArray;
        }
        
        function changePageTitle(phrase) {
            const newTitle = phrase.split('\n').join(' ');
            document.title = newTitle;
        }

        function prepForAnimation(phrase, letters, animation) {
            if (animation === animationTypes.EXPLODEY) {
                for (let i=0; i<letters.length; i++) {
                    const ltr = letters[i];
                    if (ltr.sprite) {
                        let currX = ltr.sprite.position.x;
                        let currY = ltr.sprite.position.y;
                        // TODO: change this calculation:
                        if (currX > 0) {
                            currX = (window.innerWidth/4*devicePixelRatio - currX)*Math.random() + currX;
                        } else {
                            currX = (-1*window.innerWidth/4*devicePixelRatio - currX)*Math.random() + currX;
                        }
                        if (currY > 0) {
                            currY = (window.innerWidth/4*devicePixelRatio - currY)*Math.random() + currY;
                        } else {
                            currY = (-1*window.innerWidth/4*devicePixelRatio - currX)*Math.random() + currY;
                        }
                        ltr.destX = currX;
                        ltr.destY = currY;
                    }
                }
            } else { // slidey, none
                const phraseLines = phrase.split('\n'); // split anagram into an array of "lines"
                const lineArray = getLetterObjArray(phraseLines, letters); // prepare for positioning - put letter objects in proper order 
                const letterArray = calculateLetterObjPositions(lineArray, letterHeight); // prepare for positioning - calculate letter positions
            }
        }

        function animateSwap(phrase, letters, animation) {
            let counter = 0;
            for (let i=0; i<letters.length; i++) { // TODO - change the style of for loop? everywhere?
                const ltr = letters[i];
                if (ltr.sprite) { // don't render spaces. duh.                    
                    switch (animation) {
                        case animationTypes.NONE:
                            ltr.sprite.position.x = ltr.destX;
                            ltr.sprite.position.y = ltr.destY;
                            break;
                        case animationTypes.SLIDEY:
                            gsap.to(ltr.sprite, { x: ltr.destX, y: ltr.destY, duration: 0.3, ease: "power1.in" });
                            break;
                        case animationTypes.EXPLODEY:
                        gsap.to(ltr.sprite, { 
                            x: ltr.destX, 
                            y: ltr.destY, 
                            duration: 0.3, 
                            ease: "power1.out", 
                            onComplete() {
                                counter += 1;
                                // TODO: magic numbers are bad
                                if (counter >= 15) { showNew(phrase, animationTypes.SLIDEY); }
                            }
                        });
                    }                           
                }
            }
        }
     
        function createLetterSprites(letterObjs) {
            for (let i=0; i<letterObjs.length; i++) {
                let letter = letterObjs[i];
                if (letter.id) {
                    const sprite = PIXI.Sprite.from(app.loader.resources[letter.id].texture, { roundPixels: true, resolution: devicePixelRatio }); // Magically load the PNG asynchronously
                    letter.sprite = sprite;
                    centerPoint.addChild(sprite);
                }            
            }
        }

        function onAppProgress(e) {
            // TODO
            console.log('loading:', e.progress);
        }

        function onAppError(e) {
            // TODO
            console.log('error:', e.message);
        }

        function onAppLoaded(e) {
            createLetterSprites(letters); 
            // start with "wasted potential":
            currentPhrase = showNew(siteTitle, animationTypes.NONE);
               
        }

        window.addEventListener('resize', onResize);
        var app = new PIXI.Application({ autoResize:true, resolution: devicePixelRatio, roundPixels: true, backgroundColor: 0xf1f4f9 });
        const cont = document.querySelector('.container'); 
        cont.appendChild(app.view);
        var centerPoint = new PIXI.Container({resolution: devicePixelRatio, roundPixels: true});
        app.stage.addChild(centerPoint);

        // TODO: load all assets here
        app.loader.baseUrl = 'assets/letters/';
        for (const letter of letters) {
            if (letter.id) {
                app.loader.add(letter.id, letter.id + '_01@2x.png');
            }
        }
        app.loader.onProgress.add(onAppProgress);
        app.loader.onError.add(onAppError);
        app.loader.onComplete.add(onAppLoaded);
        app.loader.load();

        // TODO: fade in

        function showNew(phrase, animation) {
            prepForAnimation(phrase, letters, animation);   
            animateSwap(phrase, letters, animation);             
        }

        function onResize() {	
            const w = window.innerWidth/devicePixelRatio;
            const h = window.innerHeight/devicePixelRatio;
            if (app) app.renderer.resize(w, h);
    
            if (centerPoint) {
                centerPoint.position.set(0.5 * w, 0.5 * h);
            }
        }

        onResize();      
    </script>
  </body>
</html>