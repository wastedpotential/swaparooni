<!doctype html>
<html>
  <head>
    <script src="https://pixijs.download/release/pixi.js"></script>
    <script src="assets.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
    </style>
  </head>
  <body>
    <script>
        // import { Container } from '@pixi/display';
        // import { Sprite } from '@pixi/sprite';

        function duplicateArray(arrayOfObjects) { 
            const dupe = arrayOfObjects.map((obj) => {
                const newObj = {...obj}  
                return newObj;
            });
            return dupe;
        }

        function populateLetterArrays(str, objectArray) {
            // console.log('pop:', str, objectsRemaining);
            const line = [];
            for (var i = 0; i < str.length; i++) {
                const nextLetter = str.charAt(i);
                // TODO: if space, handle it here
                const letterObj = objectArray.find(e => {
                    return !(e.used) && (e.char == nextLetter);
                });
                line.push(letterObj);
                letterObj.used = true;
            }
            console.log('herp:', line);
            return line;
        }

        function totalWidth(items) {
            var total = items.reduce(
                (partialSum, a) => partialSum + a.w, 0
            );
            return total;
        }

        // calculateLetterPositions() {

        // }
      
      // prep objects for parsing:
      const jerp = duplicateArray(letters);
      
      const phrase = 'salted\nnewt\npatio';
      // TODO: add a check that the anagram is valid
      const splitPhrase = phrase.split('\n');
      const lineArray = [];
      for (const str of splitPhrase) {
        //   console.log('line:', str);
        lineArray.push(populateLetterArrays(str, jerp));
      }

      
      const startY = -0.5 * lineArray.length * letterHeight;
      for (let i=0; i<lineArray.length; i++){
        const line = lineArray[i];
        const totalW = totalWidth(line);
        let lineX = -0.5 * totalW;
        const lineStartY = i * letterHeight + startY;
        for (let j=0; j<line.length; j++) {
            const ltr = line[j];
            ltr.destX = lineX + line[j].w;
            ltr.destY = lineStartY;
            lineX += line[j].w;
        }
      }
    

      
// ==================== VIEW STUFF =========================

      // Listen for window resize events
      window.addEventListener('resize', onResize);

    // Resize function window
    function onResize() {	
        const parent = app.view.parentNode;
   
        // Resize the renderer
        app.renderer.resize(parent.clientWidth, parent.clientHeight);
  
        // You can use the 'screen' property as the renderer visible
        // area, this is more useful than view.width/height because
        // it handles resolution
        if (centerPoint) {
            centerPoint.position.set(0.5 * app.screen.width, 0.5 * app.screen.height);
        }
    }

      let app = new PIXI.Application({ autoResize: true, resolution: devicePixelRatio });
      document.body.appendChild(app.view);

      const centerPoint = new PIXI.Container();
      for (let i=0; i<lineArray.length; i++) {
        const line = lineArray[i];
        for (let j=0; j<line.length; j++) {
            const ltr = line[j];
            let sprite = PIXI.Sprite.from(ltr.img); // Magically load the PNG asynchronously
            sprite.position.x = ltr.destX;
            sprite.position.y = ltr.destY;
            centerPoint.addChild(sprite);
        }
      }

      app.stage.addChild(centerPoint);

      onResize();
    </script>
  </body>
</html>